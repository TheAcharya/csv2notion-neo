# CSV2Notion Neo - Cursor Rules

## Project Context

This is CSV2Notion Neo, an advanced command-line tool for uploading and merging CSV or JSON files with images to Notion databases. The project is written in Python 3.9+ and uses Poetry for dependency management.

## Version 2.0.0+ Migration

CSV2Notion Neo has been fully migrated to use the official [Notion API](https://developers.notion.com/) and the [notion-sdk-py](https://github.com/ramnes/notion-sdk-py) library. This migration provides better reliability, security, and future compatibility. The application now uses Notion integration tokens instead of session cookies and requires database URLs to be provided for all operations.

### Migration Implementation Details

#### New File Structure
- `csv2notion_neo/notion_client_official.py`: Official Notion API client wrapper
- `csv2notion_neo/notion_db_official.py`: Database operations using official API
- `csv2notion_neo/notion_row_upload_file_official.py`: File upload operations
- `csv2notion_neo/notion_db_client_official.py`: Compatibility layer for existing code

#### Removed Components
- `csv2notion_neo/notion/` directory: Entire unofficial API implementation
- `csv2notion_neo/notion_row.py`: Old row handling classes
- `csv2notion_neo/notion_db_collection.py`: Old collection management

#### Key Implementation Changes
- Authentication: Integration tokens instead of session cookies
- Database Operations: Official databases API endpoints
- File Uploads: Official file_uploads API endpoints
- Error Handling: Official API error codes and responses
- Rate Limiting: Built-in official API rate limiting
- Property Validation: Official API property type validation

#### Compatibility Layer
- Maintains existing method signatures where possible
- Provides seamless transition from old to new API
- Handles data structure differences between APIs
- Preserves all existing functionality and features

## Dependencies

### Core Dependencies
- Python 3.9+ required
- Poetry for dependency management
- Key dependencies: notion-client (notion-sdk-py), requests, tqdm, emoji, python-dateutil, icecream

## Code Style and Standards

### Python Code Style
- Use Black formatting with 88 character line length
- Follow PEP 8 guidelines
- Use type hints throughout the codebase
- Use dataclasses for configuration objects
- Implement proper error handling with custom exceptions

### Import Organization
- Use isort for import organization
- Group imports: standard library, third-party, local
- Use absolute imports for local modules
- Avoid wildcard imports

### Naming Conventions
- Use snake_case for variables, functions, and modules
- Use PascalCase for classes
- Use UPPER_CASE for constants
- Use descriptive names that clearly indicate purpose

## Architecture Guidelines

### Module Structure
- Keep modules focused on single responsibility
- Use clear separation between CLI, data processing, and Notion integration
- Maintain loose coupling between components
- Use dependency injection where appropriate

### Error Handling
- Use custom exceptions (CriticalError, NotionError) for specific error types
- Provide meaningful error messages with context
- Log errors appropriately with proper levels
- Handle API rate limits gracefully

### Logging
- Use structured logging throughout the application
- Include context in log messages
- Support configurable log levels
- Use file-based logging for debugging

## Development Workflow

### Local Development Environment
- Use the ephemeral build script (`scripts/local-test-build.sh`) for consistent local development
- Creates isolated build environment in `.build/` directory
- No system-level Python or Poetry installation required
- Supports dependency management, testing, and binary creation
- Produces identical builds to CI/CD pipeline

### Code Quality Tools
- Run Black for code formatting
- Use isort for import sorting
- Apply flake8 and wemake-python-styleguide for linting
- Use mypy for type checking
- Maintain pre-commit hooks

### Testing Requirements
- Write unit tests for all new functionality
- Use pytest for testing framework
- Maintain good test coverage
- Use VCR for API response testing
- Test both success and failure scenarios
- Use ephemeral environment for local testing

### Git Workflow
- Use descriptive commit messages
- Create feature branches for new development
- Require pull request reviews
- Keep commits atomic and focused

## API Integration Patterns

### Notion API
- Use the official Notion API client implementation in csv2notion_neo/notion_client_official.py
- Utilise the notion-sdk-py library for all Notion API interactions
- Handle official API responses and error codes properly
- Implement proper rate limiting using official API guidelines
- Use official file_uploads endpoints for file operations
- Follow official Notion API specifications and best practices
- Reference: [notion-sdk-py documentation](https://ramnes.github.io/notion-sdk-py/)
- Reference: [Official Notion API documentation](https://developers.notion.com/)

### Hugging Face API
- Implement retry logic for model loading
- Handle authentication securely
- Provide fallback options for API failures
- Log AI processing steps appropriately

## Data Processing Guidelines

### CSV/JSON Handling
- Validate input data thoroughly
- Handle missing or malformed data gracefully
- Support different delimiters and encodings
- Implement proper column type detection

### File Operations
- Use pathlib for file path handling
- Validate file extensions and types
- Handle file uploads securely
- Implement proper cleanup of temporary files

## Performance Considerations

### Multithreading
- Use ThreadPoolExecutor for concurrent operations
- Implement proper thread safety
- Monitor thread usage and performance
- Handle thread-local data appropriately

### Memory Management
- Process large files in chunks when possible
- Avoid loading entire datasets into memory
- Implement proper resource cleanup
- Monitor memory usage in long-running operations

## Security Best Practices

### Authentication
- Never hardcode credentials in source code
- Use environment variables for sensitive data
- Implement secure token handling
- Validate authentication before operations

### Data Privacy
- Handle user data securely
- Implement proper data validation
- Log sensitive operations appropriately
- Follow privacy guidelines for AI features

## Configuration Management

### Command Line Arguments
- Use argparse for CLI argument parsing
- Provide clear help messages
- Validate argument combinations
- Support both required and optional arguments
- Note: --token (integration token) and --url (database URL) are now mandatory
- Database management: --delete-all-database-entries for archiving all pages in a database

### Environment Variables
- Use python-dotenv for environment configuration
- Provide clear documentation for required variables
- Implement fallback values where appropriate
- Validate environment configuration on startup

## Documentation Standards

### Code Documentation
- Use docstrings for all public functions and classes
- Follow Google or NumPy docstring format
- Include type information in docstrings
- Document exceptions and edge cases

### README and Documentation
- Keep README.md up to date
- Document installation and usage instructions
- Provide clear examples for common use cases
- Maintain changelog for version history

## Testing Strategy

### Unit Tests
- Test individual functions and methods
- Mock external dependencies
- Test both success and failure paths
- Maintain high test coverage

### Integration Tests
- Test API integrations with real endpoints
- Use VCR for recording API responses
- Test end-to-end workflows
- Validate error handling in real scenarios

### Performance Tests
- Test with large datasets
- Monitor memory usage
- Test concurrent operations
- Validate rate limiting behavior

## Deployment and Distribution

### Packaging
- Use Poetry for dependency management
- Maintain pyproject.toml configuration
- Support multiple Python versions
- Provide pre-compiled binaries

### CI/CD
- Automate testing and quality checks
- Use GitHub Actions for CI/CD
- Implement automated releases
- Monitor build and test status
- Support ephemeral local build system for development

## Maintenance Guidelines

### Version Management
- Follow semantic versioning (MAJOR.MINOR.PATCH)
- Maintain backward compatibility
- Document breaking changes
- Update dependencies regularly

### Bug Fixes
- Reproduce issues reliably
- Write tests for bug fixes
- Document the root cause
- Verify fixes in multiple scenarios

### Feature Development
- Plan features thoroughly
- Consider backward compatibility
- Update documentation
- Add appropriate tests

## Common Patterns

### Data Conversion
- Use the NotionRowConverter for data transformation
- Handle different column types appropriately
- Validate data before conversion
- Provide clear error messages for conversion failures

### File Upload
- Use the upload_filetype function for file handling
- Validate file types and sizes
- Handle upload failures gracefully
- Implement retry logic for transient failures

### Error Recovery
- Implement graceful degradation
- Provide fallback options
- Log recovery actions
- Notify users of issues appropriately

## Code Review Checklist

### Functionality
- Does the code work as intended?
- Are edge cases handled properly?
- Is error handling appropriate?
- Are performance implications considered?

### Code Quality
- Is the code readable and maintainable?
- Are type hints used correctly?
- Is the code properly documented?
- Are tests included and comprehensive?

### Security
- Are security best practices followed?
- Is sensitive data handled properly?
- Are input validations in place?
- Are authentication mechanisms secure?

### Integration
- Do official API integrations work correctly?
- Are rate limits respected according to official API guidelines?
- Is error handling robust with official API error codes?
- Are fallback mechanisms in place for API failures?
- Are official API changes monitored and handled appropriately?

## Troubleshooting Guidelines

### Debug Mode
- Enable verbose logging for detailed analysis
- Use file-based logging for persistent debugging
- Include context in error messages
- Preserve error state for analysis
- Use ephemeral build environment for isolated debugging

### Common Issues
- Integration token expiration or invalid tokens
- Official API rate limiting
- File upload failures through official endpoints
- Network connectivity issues
- Memory usage problems
- Database access permissions and sharing requirements
- Build environment issues (use `./scripts/local-test-build.sh --clean` to reset)
- Database deletion operations requiring proper permissions and database URL validation

### Performance Issues
- Monitor thread usage
- Check for memory leaks
- Analyze API call patterns
- Optimize data processing

## Outdated Packages Held Back Due to Dependency Constraints

The following packages are currently outdated but have not been updated because doing so would break compatibility with other dependencies in the project (such as flake8 plugins, wemake-python-styleguide, etc.):

| Package                  | Installed | Latest   | Reason Held Back                                 |
|--------------------------|-----------|----------|-------------------------------------------------|
| click                    | 8.1.8     | 8.2.1    | Transitive, constrained by parent dependencies   |
| eradicate                | 2.3.0     | 3.0.0    | Required by flake8-eradicate/wemake-styleguide   |
| flake8                   | 3.9.0     | 7.3.0    | Required by wemake-python-styleguide             |
| flake8-bandit            | 3.0.0     | 4.1.1    | Plugin, version tied to flake8                   |
| flake8-broken-line       | 0.4.0     | 1.0.0    | Plugin, version tied to flake8                   |
| flake8-bugbear           | 22.12.6   | 24.12.12 | Plugin, version tied to flake8                   |
| flake8-commas            | 2.1.0     | 4.0.0    | Plugin, version tied to flake8                   |
| flake8-eradicate         | 1.4.0     | 1.5.0    | Plugin, version tied to eradicate/flak8          |
| flake8-isort             | 4.2.0     | 6.1.2    | Plugin, version tied to flake8/isort             |
| flake8-rst-docstrings    | 0.2.7     | 0.3.1    | Plugin, version tied to flake8                   |
| isort                    | 5.13.2    | 6.0.1    | Required by flake8-isort                         |
| mccabe                   | 0.6.1     | 0.7.0    | Required by flake8 <5                            |
| pep8-naming              | 0.11.1    | 0.15.1   | Latest requires flake8 >=5                       |
| pre-commit               | 2.21.0    | 4.2.0    | Not updated to avoid breaking hooks              |
| pycodestyle              | 2.7.0     | 2.14.0   | Required by flake8 <5                            |
| pyfakefs                 | 4.7.0     | 5.9.1    | Not updated to avoid breaking tests              |
| pyflakes                 | 2.3.1     | 3.4.0    | Required by flake8 <5                            |
| pytest                   | 7.4.4     | 8.4.1    | Not updated to avoid breaking test compatibility |
| pytest-cov               | 3.0.0     | 6.2.1    | Not updated to avoid breaking test compatibility |
| testfixtures             | 7.2.2     | 9.1.0    | Not updated to avoid breaking test compatibility |
| wemake-python-styleguide | 0.16.1    | 1.3.0    | Latest requires Python >=3.10                    |

> These packages will be updated when their dependencies allow, or when the project drops support for Python 3.9 or older plugin versions.

This cursorrule file should be kept in sync with the AGENT.MD file to ensure consistent development practices and project understanding. 